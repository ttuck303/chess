Open Questions

1. what classes should be included?
	game class
	board class
	piece class
	(maybe) a class for each type of piece? <gut here is saying yes, they can inherit from piece class. 
	This will allow each piece to have a more lightweight array of available moves, since it will not 
	have to carry around the available moves of each of the other pieces. 



2. how do you check that a move is legal?
	- approach 1:
		- start with all the possible moves by a piece on a blank board, stored in an array
		- loop through each move and remove illegal moves:
			- moves that are off the board
			- moves that clash with own team
			- moves that put own team into check

			question 2a. Is this an egregious amount of calculating?
			do a worst case scenario analysis:
				32 pieces to start with
				only have to analyze the given piece
				in fact, you only have to analyze the given move - no need to generate every possible move!

				this unique movement by each piece furthers the argument for each piece having its own class
					need to do a quick review of inheritance...


3. how do you store the legal moves for a given piece? -> see #2a decision to make each piece its own class

4. what are the class and super class attributes and methods? In fact, outline all classes and what they should do here:

	Board Class
		check for check condition
		keeps track of movement history (would be really cool if you could load and save games from actual chess files, which is a thing)
		? does it need a custom data structure, or is a nested array as good as it gets? hash table? Something in my mind thinks that a hash would be nice since its 'flat'. Not sure if this is a valid reason to prefer them though, seeing as you will still need to enter the row/column combination in the same way each time. But this way you could more easily index one or the other with letters as they do in real chess, ie a7 to b4 (this is called file for the letters)
			? how do you pass specific objects into a hash 

	Piece Class
		assign symbol method
		counting pieces?

	Sub Piece
		team 
		type
		text representation
		symbol
		movement pattern
		check (king only) -> this is actually a board condition


		Pawn Class

			start with pawn and deal with character-specific movements
				can never move forward if a piece occupies the next spot up
				can move 1 or 2 if its the piece's first time moving

		King Class

		An aside: quick way to check for check condition
			1. scan all spaces immediately surrounding the king
				if they are either OOB or own team, then continue;
				if they are blank, search out in the direction of the blankness until another piece or a wall is detected


	# how to keep track of moves?
# three cases:
# discrete movers (knights)
# continuous movers (rooks, bishops, queens)
# conditional movers (king, pawn)
# technically, they are all conditional movers, as an piece could move in a way that would cause check
# which class should be responsible for making sure that a move doesn't move the king into check?

# Where the game is right now:
# display board
# get a player to move


____


Update 2015-09-14

As I work to convert the board to a hash, I am wondering if this is an intelligent / justified move. 
Displaying is certainly more complicated in this set up. 
Moving or checking spaces requires more legwork, whereas a nested array has built in structure that seems more beneficial - being able to scan a spot

Advantages of Hash Board
- spaces are named
	- allowing you to keep track of moves
	- preventing ambiguity when entering moves
- can more cleanly populate a board during initialization



Advantages of Nested Array Board


----

How do you represent a kind of piece's acceptable move patterns?
	idea 1: create acceptable x-y differences from start to finish, and check for edge cases in a seperate method
		note: direcitonality matters in some cases (pawns). Directionality is dependent on the color and board set up. Assuming board is the same every time, so I can use true value of y difference. 


		Pawn Movements and Special Cases
				# if white, move up; if black, move down
				# if first move, allowed to go 2, otherwise just 1
				# if enemy diagonal, allowed to move diagonally and take
				# if reach the end, become any piece the user wants


		Chess Game class should be doing the checks of situation involving board and piece(s)
		Piece class can check for individual illegal moves
		Board should not do any checking
		

----

Spaces between method
	vertical 							x_diff = 0
		going up a3 a5					y_diff > 0
		going down a5 a3				y_diff < 0
	horizontal							y_diff = 0
		going left h2 a2				x_diff < 0
		going right a2 h2				x_diff > 0
	diagonal 							x_diff.abs = 1 && y_diff.abs = 1
		going up-right					x_diff and y_diff same sign (either + or -)
			moving right a2 d5			both are positive
			moving left d5 a2			both are negative
		going down-right				x_diff and y_diff different signs
			moving right a5 e1			x_diff > 0, y_diff < 0
			moving left e1 a5			x_diff < 0, y_diff > 0

	difficulty is that Range is one way, ascending only
	directionality doesn't matter for my methods
	there is really no difference between direction of movement, ie a->b is same as b->a, as long as you enter the arguments properly
		for vertical, enter the one with the smaller row first
		for horizontal, enter the one with the smaller letter first
		for diagonal, 
			for up-right, enter the smaller first (both will be smaller)
			for down-right, special case where we must reverse a range at some point
				so put smaller letter first
				create number range in ascending order, and then reverse it

------

To Do List (not in order)
1. update all piece classes with methods to check that moves are acceptable (complete, unchecked)
2. write an algorithm to see if a team is in check / checkm8
3. write a method to convert a pawn to any desired piece if it reaches the opposite end of the board
4. implement a way to play out whole games by entering game history
5. refactor / clean up
6. build some AI!
7. connect with online chess API and start pwning n00bz
8. display sidelined pieces
9. make sure that the @moved? flag on pieces is updated properly

-----

Checking if a king is in check brainstorm

approach:
- check each space surrounding the king
	- if enemy piece in immediate proximity of a certain type, you could be in check
		- pawn diagonally
		- rook in a 'perpendicular' space
		- queen in any space
		- bishop diagonally
		- king in any space
	- if there are any gaps, extend out in a straight line until you see a piece
		- if its an enemy of a certain type, you know you're in check
			- rook in a perpendicular space
			- bishop in a diagonal space
			- queen in either type
- check the spaces around a king where an enemy knight could be hiding
	- if an enemy knight is in one of those spaces, you're in check

steps
1. generate a list of all immediate surrounding spaces
2. check these spaces for enemies
3. check these spaces for gaps
4. create list of spaces in a straight line from gaps up to next piece
5. check the list in 4 for enemies of a particular type
6. check knight territory





